// Code generated by go-swagger; DO NOT EDIT.

package settings

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SettingsSettingsLoggingTestCreateReader is a Reader for the SettingsSettingsLoggingTestCreate structure.
type SettingsSettingsLoggingTestCreateReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *SettingsSettingsLoggingTestCreateReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewSettingsSettingsLoggingTestCreateCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 403:
		result := NewSettingsSettingsLoggingTestCreateForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 409:
		result := NewSettingsSettingsLoggingTestCreateConflict()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewSettingsSettingsLoggingTestCreateCreated creates a SettingsSettingsLoggingTestCreateCreated with default headers values
func NewSettingsSettingsLoggingTestCreateCreated() *SettingsSettingsLoggingTestCreateCreated {
	return &SettingsSettingsLoggingTestCreateCreated{}
}

/*SettingsSettingsLoggingTestCreateCreated handles this case with default header values.

SettingsSettingsLoggingTestCreateCreated settings settings logging test create created
*/
type SettingsSettingsLoggingTestCreateCreated struct {
}

func (o *SettingsSettingsLoggingTestCreateCreated) Error() string {
	return fmt.Sprintf("[POST /api/v2/settings/logging/test/][%d] settingsSettingsLoggingTestCreateCreated ", 201)
}

func (o *SettingsSettingsLoggingTestCreateCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewSettingsSettingsLoggingTestCreateForbidden creates a SettingsSettingsLoggingTestCreateForbidden with default headers values
func NewSettingsSettingsLoggingTestCreateForbidden() *SettingsSettingsLoggingTestCreateForbidden {
	return &SettingsSettingsLoggingTestCreateForbidden{}
}

/*SettingsSettingsLoggingTestCreateForbidden handles this case with default header values.

No Permission Response
*/
type SettingsSettingsLoggingTestCreateForbidden struct {
}

func (o *SettingsSettingsLoggingTestCreateForbidden) Error() string {
	return fmt.Sprintf("[POST /api/v2/settings/logging/test/][%d] settingsSettingsLoggingTestCreateForbidden ", 403)
}

func (o *SettingsSettingsLoggingTestCreateForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewSettingsSettingsLoggingTestCreateConflict creates a SettingsSettingsLoggingTestCreateConflict with default headers values
func NewSettingsSettingsLoggingTestCreateConflict() *SettingsSettingsLoggingTestCreateConflict {
	return &SettingsSettingsLoggingTestCreateConflict{}
}

/*SettingsSettingsLoggingTestCreateConflict handles this case with default header values.

Request Conflict
*/
type SettingsSettingsLoggingTestCreateConflict struct {
}

func (o *SettingsSettingsLoggingTestCreateConflict) Error() string {
	return fmt.Sprintf("[POST /api/v2/settings/logging/test/][%d] settingsSettingsLoggingTestCreateConflict ", 409)
}

func (o *SettingsSettingsLoggingTestCreateConflict) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

/*SettingsSettingsLoggingTestCreateBody settings settings logging test create body
swagger:model SettingsSettingsLoggingTestCreateBody
*/
type SettingsSettingsLoggingTestCreateBody struct {

	// Enable capturing activity for the activity stream.
	// Required: true
	ACTIVITYSTREAMENABLED *bool `json:"ACTIVITY_STREAM_ENABLED"`

	// Enable capturing activity for the activity stream when running inventory sync.
	// Required: true
	ACTIVITYSTREAMENABLEDFORINVENTORYSYNC *bool `json:"ACTIVITY_STREAM_ENABLED_FOR_INVENTORY_SYNC"`

	// List of modules allowed to be used by ad-hoc jobs.
	ADHOCCOMMANDS []string `json:"AD_HOC_COMMANDS"`

	// Ansible allows variable substitution via the Jinja2 templating language for --extra-vars. This poses a potential security risk where Tower users with the ability to specify extra vars at job launch time can use Jinja2 templates to run arbitrary Python.  It is recommended that this value be set to "template" or "never".
	// Required: true
	ALLOWJINJAINEXTRAVARS *string `json:"ALLOW_JINJA_IN_EXTRA_VARS"`

	// For security reasons, users from external auth providers (LDAP, SAML, SSO, Radius, and others) are not allowed to create OAuth2 tokens. To change this behavior, enable this setting. Existing tokens will not be deleted when this setting is toggled off.
	ALLOWOAUTH2FOREXTERNALUSERS bool `json:"ALLOW_OAUTH2_FOR_EXTERNAL_USERS,omitempty"`

	// Maximum time, in seconds, that stored Ansible facts are considered valid since the last time they were modified. Only valid, non-stale, facts will be accessible by a playbook. Note, this does not influence the deletion of ansible_facts from the database. Use a value of 0 to indicate that no timeout should be imposed.
	ANSIBLEFACTCACHETIMEOUT int64 `json:"ANSIBLE_FACT_CACHE_TIMEOUT,omitempty"`

	// Enable HTTP Basic Auth for the API Browser.
	// Required: true
	AUTHBASICENABLED *bool `json:"AUTH_BASIC_ENABLED"`

	// DN (Distinguished Name) of user to bind for all search queries. This is the system user account we will use to login to query LDAP for other user information. Refer to the Ansible Tower documentation for example syntax.
	AUTHLDAP1BINDDN string `json:"AUTH_LDAP_1_BIND_DN,omitempty"`

	// Password used to bind LDAP user account.
	AUTHLDAP1BINDPASSWORD string `json:"AUTH_LDAP_1_BIND_PASSWORD,omitempty"`

	// Additional options to set for the LDAP connection.  LDAP referrals are disabled by default (to prevent certain LDAP queries from hanging with AD). Option names should be strings (e.g. "OPT_REFERRALS"). Refer to https://www.python-ldap.org/doc/html/ldap.html#options for possible options and values that can be set.
	AUTHLDAP1CONNECTIONOPTIONS interface{} `json:"AUTH_LDAP_1_CONNECTION_OPTIONS,omitempty"`

	// Group DN denied from login. If specified, user will not be allowed to login if a member of this group.  Only one deny group is supported.
	AUTHLDAP1DENYGROUP string `json:"AUTH_LDAP_1_DENY_GROUP,omitempty"`

	// Users are mapped to organizations based on their membership in LDAP groups. This setting defines the LDAP search query to find groups. Unlike the user search, group search does not support LDAPSearchUnion.
	AUTHLDAP1GROUPSEARCH []string `json:"AUTH_LDAP_1_GROUP_SEARCH"`

	// The group type may need to be changed based on the type of the LDAP server.  Values are listed at: https://django-auth-ldap.readthedocs.io/en/stable/groups.html#types-of-groups
	AUTHLDAP1GROUPTYPE string `json:"AUTH_LDAP_1_GROUP_TYPE,omitempty"`

	// Key value parameters to send the chosen group type init method.
	AUTHLDAP1GROUPTYPEPARAMS interface{} `json:"AUTH_LDAP_1_GROUP_TYPE_PARAMS,omitempty"`

	// Mapping between organization admins/users and LDAP groups. This controls which users are placed into which Tower organizations relative to their LDAP group memberships. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAP1ORGANIZATIONMAP interface{} `json:"AUTH_LDAP_1_ORGANIZATION_MAP,omitempty"`

	// Group DN required to login. If specified, user must be a member of this group to login via LDAP. If not set, everyone in LDAP that matches the user search will be able to login via Tower. Only one require group is supported.
	AUTHLDAP1REQUIREGROUP string `json:"AUTH_LDAP_1_REQUIRE_GROUP,omitempty"`

	// URI to connect to LDAP server, such as "ldap://ldap.example.com:389" (non-SSL) or "ldaps://ldap.example.com:636" (SSL). Multiple LDAP servers may be specified by separating with spaces or commas. LDAP authentication is disabled if this parameter is empty.
	AUTHLDAP1SERVERURI string `json:"AUTH_LDAP_1_SERVER_URI,omitempty"`

	// Whether to enable TLS when the LDAP connection is not using SSL.
	AUTHLDAP1STARTTLS bool `json:"AUTH_LDAP_1_START_TLS,omitempty"`

	// Mapping between team members (users) and LDAP groups. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAP1TEAMMAP interface{} `json:"AUTH_LDAP_1_TEAM_MAP,omitempty"`

	// Mapping of LDAP user schema to Tower API user attributes. The default setting is valid for ActiveDirectory but users with other LDAP configurations may need to change the values. Refer to the Ansible Tower documentation for additional details.
	AUTHLDAP1USERATTRMAP interface{} `json:"AUTH_LDAP_1_USER_ATTR_MAP,omitempty"`

	// Alternative to user search, if user DNs are all of the same format. This approach is more efficient for user lookups than searching if it is usable in your organizational environment. If this setting has a value it will be used instead of AUTH_LDAP_USER_SEARCH.
	AUTHLDAP1USERDNTEMPLATE string `json:"AUTH_LDAP_1_USER_DN_TEMPLATE,omitempty"`

	// Retrieve users from a given group. At this time, superuser and system auditors are the only groups supported. Refer to the Ansible Tower documentation for more detail.
	AUTHLDAP1USERFLAGSBYGROUP interface{} `json:"AUTH_LDAP_1_USER_FLAGS_BY_GROUP,omitempty"`

	// LDAP search query to find users.  Any user that matches the given pattern will be able to login to Tower.  The user should also be mapped into a Tower organization (as defined in the AUTH_LDAP_ORGANIZATION_MAP setting).  If multiple search queries need to be supported use of "LDAPUnion" is possible. See Tower documentation for details.
	AUTHLDAP1USERSEARCH []string `json:"AUTH_LDAP_1_USER_SEARCH"`

	// DN (Distinguished Name) of user to bind for all search queries. This is the system user account we will use to login to query LDAP for other user information. Refer to the Ansible Tower documentation for example syntax.
	AUTHLDAP2BINDDN string `json:"AUTH_LDAP_2_BIND_DN,omitempty"`

	// Password used to bind LDAP user account.
	AUTHLDAP2BINDPASSWORD string `json:"AUTH_LDAP_2_BIND_PASSWORD,omitempty"`

	// Additional options to set for the LDAP connection.  LDAP referrals are disabled by default (to prevent certain LDAP queries from hanging with AD). Option names should be strings (e.g. "OPT_REFERRALS"). Refer to https://www.python-ldap.org/doc/html/ldap.html#options for possible options and values that can be set.
	AUTHLDAP2CONNECTIONOPTIONS interface{} `json:"AUTH_LDAP_2_CONNECTION_OPTIONS,omitempty"`

	// Group DN denied from login. If specified, user will not be allowed to login if a member of this group.  Only one deny group is supported.
	AUTHLDAP2DENYGROUP string `json:"AUTH_LDAP_2_DENY_GROUP,omitempty"`

	// Users are mapped to organizations based on their membership in LDAP groups. This setting defines the LDAP search query to find groups. Unlike the user search, group search does not support LDAPSearchUnion.
	AUTHLDAP2GROUPSEARCH []string `json:"AUTH_LDAP_2_GROUP_SEARCH"`

	// The group type may need to be changed based on the type of the LDAP server.  Values are listed at: https://django-auth-ldap.readthedocs.io/en/stable/groups.html#types-of-groups
	AUTHLDAP2GROUPTYPE string `json:"AUTH_LDAP_2_GROUP_TYPE,omitempty"`

	// Key value parameters to send the chosen group type init method.
	AUTHLDAP2GROUPTYPEPARAMS interface{} `json:"AUTH_LDAP_2_GROUP_TYPE_PARAMS,omitempty"`

	// Mapping between organization admins/users and LDAP groups. This controls which users are placed into which Tower organizations relative to their LDAP group memberships. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAP2ORGANIZATIONMAP interface{} `json:"AUTH_LDAP_2_ORGANIZATION_MAP,omitempty"`

	// Group DN required to login. If specified, user must be a member of this group to login via LDAP. If not set, everyone in LDAP that matches the user search will be able to login via Tower. Only one require group is supported.
	AUTHLDAP2REQUIREGROUP string `json:"AUTH_LDAP_2_REQUIRE_GROUP,omitempty"`

	// URI to connect to LDAP server, such as "ldap://ldap.example.com:389" (non-SSL) or "ldaps://ldap.example.com:636" (SSL). Multiple LDAP servers may be specified by separating with spaces or commas. LDAP authentication is disabled if this parameter is empty.
	AUTHLDAP2SERVERURI string `json:"AUTH_LDAP_2_SERVER_URI,omitempty"`

	// Whether to enable TLS when the LDAP connection is not using SSL.
	AUTHLDAP2STARTTLS bool `json:"AUTH_LDAP_2_START_TLS,omitempty"`

	// Mapping between team members (users) and LDAP groups. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAP2TEAMMAP interface{} `json:"AUTH_LDAP_2_TEAM_MAP,omitempty"`

	// Mapping of LDAP user schema to Tower API user attributes. The default setting is valid for ActiveDirectory but users with other LDAP configurations may need to change the values. Refer to the Ansible Tower documentation for additional details.
	AUTHLDAP2USERATTRMAP interface{} `json:"AUTH_LDAP_2_USER_ATTR_MAP,omitempty"`

	// Alternative to user search, if user DNs are all of the same format. This approach is more efficient for user lookups than searching if it is usable in your organizational environment. If this setting has a value it will be used instead of AUTH_LDAP_USER_SEARCH.
	AUTHLDAP2USERDNTEMPLATE string `json:"AUTH_LDAP_2_USER_DN_TEMPLATE,omitempty"`

	// Retrieve users from a given group. At this time, superuser and system auditors are the only groups supported. Refer to the Ansible Tower documentation for more detail.
	AUTHLDAP2USERFLAGSBYGROUP interface{} `json:"AUTH_LDAP_2_USER_FLAGS_BY_GROUP,omitempty"`

	// LDAP search query to find users.  Any user that matches the given pattern will be able to login to Tower.  The user should also be mapped into a Tower organization (as defined in the AUTH_LDAP_ORGANIZATION_MAP setting).  If multiple search queries need to be supported use of "LDAPUnion" is possible. See Tower documentation for details.
	AUTHLDAP2USERSEARCH []string `json:"AUTH_LDAP_2_USER_SEARCH"`

	// DN (Distinguished Name) of user to bind for all search queries. This is the system user account we will use to login to query LDAP for other user information. Refer to the Ansible Tower documentation for example syntax.
	AUTHLDAP3BINDDN string `json:"AUTH_LDAP_3_BIND_DN,omitempty"`

	// Password used to bind LDAP user account.
	AUTHLDAP3BINDPASSWORD string `json:"AUTH_LDAP_3_BIND_PASSWORD,omitempty"`

	// Additional options to set for the LDAP connection.  LDAP referrals are disabled by default (to prevent certain LDAP queries from hanging with AD). Option names should be strings (e.g. "OPT_REFERRALS"). Refer to https://www.python-ldap.org/doc/html/ldap.html#options for possible options and values that can be set.
	AUTHLDAP3CONNECTIONOPTIONS interface{} `json:"AUTH_LDAP_3_CONNECTION_OPTIONS,omitempty"`

	// Group DN denied from login. If specified, user will not be allowed to login if a member of this group.  Only one deny group is supported.
	AUTHLDAP3DENYGROUP string `json:"AUTH_LDAP_3_DENY_GROUP,omitempty"`

	// Users are mapped to organizations based on their membership in LDAP groups. This setting defines the LDAP search query to find groups. Unlike the user search, group search does not support LDAPSearchUnion.
	AUTHLDAP3GROUPSEARCH []string `json:"AUTH_LDAP_3_GROUP_SEARCH"`

	// The group type may need to be changed based on the type of the LDAP server.  Values are listed at: https://django-auth-ldap.readthedocs.io/en/stable/groups.html#types-of-groups
	AUTHLDAP3GROUPTYPE string `json:"AUTH_LDAP_3_GROUP_TYPE,omitempty"`

	// Key value parameters to send the chosen group type init method.
	AUTHLDAP3GROUPTYPEPARAMS interface{} `json:"AUTH_LDAP_3_GROUP_TYPE_PARAMS,omitempty"`

	// Mapping between organization admins/users and LDAP groups. This controls which users are placed into which Tower organizations relative to their LDAP group memberships. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAP3ORGANIZATIONMAP interface{} `json:"AUTH_LDAP_3_ORGANIZATION_MAP,omitempty"`

	// Group DN required to login. If specified, user must be a member of this group to login via LDAP. If not set, everyone in LDAP that matches the user search will be able to login via Tower. Only one require group is supported.
	AUTHLDAP3REQUIREGROUP string `json:"AUTH_LDAP_3_REQUIRE_GROUP,omitempty"`

	// URI to connect to LDAP server, such as "ldap://ldap.example.com:389" (non-SSL) or "ldaps://ldap.example.com:636" (SSL). Multiple LDAP servers may be specified by separating with spaces or commas. LDAP authentication is disabled if this parameter is empty.
	AUTHLDAP3SERVERURI string `json:"AUTH_LDAP_3_SERVER_URI,omitempty"`

	// Whether to enable TLS when the LDAP connection is not using SSL.
	AUTHLDAP3STARTTLS bool `json:"AUTH_LDAP_3_START_TLS,omitempty"`

	// Mapping between team members (users) and LDAP groups. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAP3TEAMMAP interface{} `json:"AUTH_LDAP_3_TEAM_MAP,omitempty"`

	// Mapping of LDAP user schema to Tower API user attributes. The default setting is valid for ActiveDirectory but users with other LDAP configurations may need to change the values. Refer to the Ansible Tower documentation for additional details.
	AUTHLDAP3USERATTRMAP interface{} `json:"AUTH_LDAP_3_USER_ATTR_MAP,omitempty"`

	// Alternative to user search, if user DNs are all of the same format. This approach is more efficient for user lookups than searching if it is usable in your organizational environment. If this setting has a value it will be used instead of AUTH_LDAP_USER_SEARCH.
	AUTHLDAP3USERDNTEMPLATE string `json:"AUTH_LDAP_3_USER_DN_TEMPLATE,omitempty"`

	// Retrieve users from a given group. At this time, superuser and system auditors are the only groups supported. Refer to the Ansible Tower documentation for more detail.
	AUTHLDAP3USERFLAGSBYGROUP interface{} `json:"AUTH_LDAP_3_USER_FLAGS_BY_GROUP,omitempty"`

	// LDAP search query to find users.  Any user that matches the given pattern will be able to login to Tower.  The user should also be mapped into a Tower organization (as defined in the AUTH_LDAP_ORGANIZATION_MAP setting).  If multiple search queries need to be supported use of "LDAPUnion" is possible. See Tower documentation for details.
	AUTHLDAP3USERSEARCH []string `json:"AUTH_LDAP_3_USER_SEARCH"`

	// DN (Distinguished Name) of user to bind for all search queries. This is the system user account we will use to login to query LDAP for other user information. Refer to the Ansible Tower documentation for example syntax.
	AUTHLDAP4BINDDN string `json:"AUTH_LDAP_4_BIND_DN,omitempty"`

	// Password used to bind LDAP user account.
	AUTHLDAP4BINDPASSWORD string `json:"AUTH_LDAP_4_BIND_PASSWORD,omitempty"`

	// Additional options to set for the LDAP connection.  LDAP referrals are disabled by default (to prevent certain LDAP queries from hanging with AD). Option names should be strings (e.g. "OPT_REFERRALS"). Refer to https://www.python-ldap.org/doc/html/ldap.html#options for possible options and values that can be set.
	AUTHLDAP4CONNECTIONOPTIONS interface{} `json:"AUTH_LDAP_4_CONNECTION_OPTIONS,omitempty"`

	// Group DN denied from login. If specified, user will not be allowed to login if a member of this group.  Only one deny group is supported.
	AUTHLDAP4DENYGROUP string `json:"AUTH_LDAP_4_DENY_GROUP,omitempty"`

	// Users are mapped to organizations based on their membership in LDAP groups. This setting defines the LDAP search query to find groups. Unlike the user search, group search does not support LDAPSearchUnion.
	AUTHLDAP4GROUPSEARCH []string `json:"AUTH_LDAP_4_GROUP_SEARCH"`

	// The group type may need to be changed based on the type of the LDAP server.  Values are listed at: https://django-auth-ldap.readthedocs.io/en/stable/groups.html#types-of-groups
	AUTHLDAP4GROUPTYPE string `json:"AUTH_LDAP_4_GROUP_TYPE,omitempty"`

	// Key value parameters to send the chosen group type init method.
	AUTHLDAP4GROUPTYPEPARAMS interface{} `json:"AUTH_LDAP_4_GROUP_TYPE_PARAMS,omitempty"`

	// Mapping between organization admins/users and LDAP groups. This controls which users are placed into which Tower organizations relative to their LDAP group memberships. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAP4ORGANIZATIONMAP interface{} `json:"AUTH_LDAP_4_ORGANIZATION_MAP,omitempty"`

	// Group DN required to login. If specified, user must be a member of this group to login via LDAP. If not set, everyone in LDAP that matches the user search will be able to login via Tower. Only one require group is supported.
	AUTHLDAP4REQUIREGROUP string `json:"AUTH_LDAP_4_REQUIRE_GROUP,omitempty"`

	// URI to connect to LDAP server, such as "ldap://ldap.example.com:389" (non-SSL) or "ldaps://ldap.example.com:636" (SSL). Multiple LDAP servers may be specified by separating with spaces or commas. LDAP authentication is disabled if this parameter is empty.
	AUTHLDAP4SERVERURI string `json:"AUTH_LDAP_4_SERVER_URI,omitempty"`

	// Whether to enable TLS when the LDAP connection is not using SSL.
	AUTHLDAP4STARTTLS bool `json:"AUTH_LDAP_4_START_TLS,omitempty"`

	// Mapping between team members (users) and LDAP groups. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAP4TEAMMAP interface{} `json:"AUTH_LDAP_4_TEAM_MAP,omitempty"`

	// Mapping of LDAP user schema to Tower API user attributes. The default setting is valid for ActiveDirectory but users with other LDAP configurations may need to change the values. Refer to the Ansible Tower documentation for additional details.
	AUTHLDAP4USERATTRMAP interface{} `json:"AUTH_LDAP_4_USER_ATTR_MAP,omitempty"`

	// Alternative to user search, if user DNs are all of the same format. This approach is more efficient for user lookups than searching if it is usable in your organizational environment. If this setting has a value it will be used instead of AUTH_LDAP_USER_SEARCH.
	AUTHLDAP4USERDNTEMPLATE string `json:"AUTH_LDAP_4_USER_DN_TEMPLATE,omitempty"`

	// Retrieve users from a given group. At this time, superuser and system auditors are the only groups supported. Refer to the Ansible Tower documentation for more detail.
	AUTHLDAP4USERFLAGSBYGROUP interface{} `json:"AUTH_LDAP_4_USER_FLAGS_BY_GROUP,omitempty"`

	// LDAP search query to find users.  Any user that matches the given pattern will be able to login to Tower.  The user should also be mapped into a Tower organization (as defined in the AUTH_LDAP_ORGANIZATION_MAP setting).  If multiple search queries need to be supported use of "LDAPUnion" is possible. See Tower documentation for details.
	AUTHLDAP4USERSEARCH []string `json:"AUTH_LDAP_4_USER_SEARCH"`

	// DN (Distinguished Name) of user to bind for all search queries. This is the system user account we will use to login to query LDAP for other user information. Refer to the Ansible Tower documentation for example syntax.
	AUTHLDAP5BINDDN string `json:"AUTH_LDAP_5_BIND_DN,omitempty"`

	// Password used to bind LDAP user account.
	AUTHLDAP5BINDPASSWORD string `json:"AUTH_LDAP_5_BIND_PASSWORD,omitempty"`

	// Additional options to set for the LDAP connection.  LDAP referrals are disabled by default (to prevent certain LDAP queries from hanging with AD). Option names should be strings (e.g. "OPT_REFERRALS"). Refer to https://www.python-ldap.org/doc/html/ldap.html#options for possible options and values that can be set.
	AUTHLDAP5CONNECTIONOPTIONS interface{} `json:"AUTH_LDAP_5_CONNECTION_OPTIONS,omitempty"`

	// Group DN denied from login. If specified, user will not be allowed to login if a member of this group.  Only one deny group is supported.
	AUTHLDAP5DENYGROUP string `json:"AUTH_LDAP_5_DENY_GROUP,omitempty"`

	// Users are mapped to organizations based on their membership in LDAP groups. This setting defines the LDAP search query to find groups. Unlike the user search, group search does not support LDAPSearchUnion.
	AUTHLDAP5GROUPSEARCH []string `json:"AUTH_LDAP_5_GROUP_SEARCH"`

	// The group type may need to be changed based on the type of the LDAP server.  Values are listed at: https://django-auth-ldap.readthedocs.io/en/stable/groups.html#types-of-groups
	AUTHLDAP5GROUPTYPE string `json:"AUTH_LDAP_5_GROUP_TYPE,omitempty"`

	// Key value parameters to send the chosen group type init method.
	AUTHLDAP5GROUPTYPEPARAMS interface{} `json:"AUTH_LDAP_5_GROUP_TYPE_PARAMS,omitempty"`

	// Mapping between organization admins/users and LDAP groups. This controls which users are placed into which Tower organizations relative to their LDAP group memberships. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAP5ORGANIZATIONMAP interface{} `json:"AUTH_LDAP_5_ORGANIZATION_MAP,omitempty"`

	// Group DN required to login. If specified, user must be a member of this group to login via LDAP. If not set, everyone in LDAP that matches the user search will be able to login via Tower. Only one require group is supported.
	AUTHLDAP5REQUIREGROUP string `json:"AUTH_LDAP_5_REQUIRE_GROUP,omitempty"`

	// URI to connect to LDAP server, such as "ldap://ldap.example.com:389" (non-SSL) or "ldaps://ldap.example.com:636" (SSL). Multiple LDAP servers may be specified by separating with spaces or commas. LDAP authentication is disabled if this parameter is empty.
	AUTHLDAP5SERVERURI string `json:"AUTH_LDAP_5_SERVER_URI,omitempty"`

	// Whether to enable TLS when the LDAP connection is not using SSL.
	AUTHLDAP5STARTTLS bool `json:"AUTH_LDAP_5_START_TLS,omitempty"`

	// Mapping between team members (users) and LDAP groups. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAP5TEAMMAP interface{} `json:"AUTH_LDAP_5_TEAM_MAP,omitempty"`

	// Mapping of LDAP user schema to Tower API user attributes. The default setting is valid for ActiveDirectory but users with other LDAP configurations may need to change the values. Refer to the Ansible Tower documentation for additional details.
	AUTHLDAP5USERATTRMAP interface{} `json:"AUTH_LDAP_5_USER_ATTR_MAP,omitempty"`

	// Alternative to user search, if user DNs are all of the same format. This approach is more efficient for user lookups than searching if it is usable in your organizational environment. If this setting has a value it will be used instead of AUTH_LDAP_USER_SEARCH.
	AUTHLDAP5USERDNTEMPLATE string `json:"AUTH_LDAP_5_USER_DN_TEMPLATE,omitempty"`

	// Retrieve users from a given group. At this time, superuser and system auditors are the only groups supported. Refer to the Ansible Tower documentation for more detail.
	AUTHLDAP5USERFLAGSBYGROUP interface{} `json:"AUTH_LDAP_5_USER_FLAGS_BY_GROUP,omitempty"`

	// LDAP search query to find users.  Any user that matches the given pattern will be able to login to Tower.  The user should also be mapped into a Tower organization (as defined in the AUTH_LDAP_ORGANIZATION_MAP setting).  If multiple search queries need to be supported use of "LDAPUnion" is possible. See Tower documentation for details.
	AUTHLDAP5USERSEARCH []string `json:"AUTH_LDAP_5_USER_SEARCH"`

	// DN (Distinguished Name) of user to bind for all search queries. This is the system user account we will use to login to query LDAP for other user information. Refer to the Ansible Tower documentation for example syntax.
	AUTHLDAPBINDDN string `json:"AUTH_LDAP_BIND_DN,omitempty"`

	// Password used to bind LDAP user account.
	AUTHLDAPBINDPASSWORD string `json:"AUTH_LDAP_BIND_PASSWORD,omitempty"`

	// Additional options to set for the LDAP connection.  LDAP referrals are disabled by default (to prevent certain LDAP queries from hanging with AD). Option names should be strings (e.g. "OPT_REFERRALS"). Refer to https://www.python-ldap.org/doc/html/ldap.html#options for possible options and values that can be set.
	AUTHLDAPCONNECTIONOPTIONS interface{} `json:"AUTH_LDAP_CONNECTION_OPTIONS,omitempty"`

	// Group DN denied from login. If specified, user will not be allowed to login if a member of this group.  Only one deny group is supported.
	AUTHLDAPDENYGROUP string `json:"AUTH_LDAP_DENY_GROUP,omitempty"`

	// Users are mapped to organizations based on their membership in LDAP groups. This setting defines the LDAP search query to find groups. Unlike the user search, group search does not support LDAPSearchUnion.
	AUTHLDAPGROUPSEARCH []string `json:"AUTH_LDAP_GROUP_SEARCH"`

	// The group type may need to be changed based on the type of the LDAP server.  Values are listed at: https://django-auth-ldap.readthedocs.io/en/stable/groups.html#types-of-groups
	AUTHLDAPGROUPTYPE string `json:"AUTH_LDAP_GROUP_TYPE,omitempty"`

	// Key value parameters to send the chosen group type init method.
	AUTHLDAPGROUPTYPEPARAMS interface{} `json:"AUTH_LDAP_GROUP_TYPE_PARAMS,omitempty"`

	// Mapping between organization admins/users and LDAP groups. This controls which users are placed into which Tower organizations relative to their LDAP group memberships. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAPORGANIZATIONMAP interface{} `json:"AUTH_LDAP_ORGANIZATION_MAP,omitempty"`

	// Group DN required to login. If specified, user must be a member of this group to login via LDAP. If not set, everyone in LDAP that matches the user search will be able to login via Tower. Only one require group is supported.
	AUTHLDAPREQUIREGROUP string `json:"AUTH_LDAP_REQUIRE_GROUP,omitempty"`

	// URI to connect to LDAP server, such as "ldap://ldap.example.com:389" (non-SSL) or "ldaps://ldap.example.com:636" (SSL). Multiple LDAP servers may be specified by separating with spaces or commas. LDAP authentication is disabled if this parameter is empty.
	AUTHLDAPSERVERURI string `json:"AUTH_LDAP_SERVER_URI,omitempty"`

	// Whether to enable TLS when the LDAP connection is not using SSL.
	AUTHLDAPSTARTTLS bool `json:"AUTH_LDAP_START_TLS,omitempty"`

	// Mapping between team members (users) and LDAP groups. Configuration details are available in the Ansible Tower documentation.
	AUTHLDAPTEAMMAP interface{} `json:"AUTH_LDAP_TEAM_MAP,omitempty"`

	// Mapping of LDAP user schema to Tower API user attributes. The default setting is valid for ActiveDirectory but users with other LDAP configurations may need to change the values. Refer to the Ansible Tower documentation for additional details.
	AUTHLDAPUSERATTRMAP interface{} `json:"AUTH_LDAP_USER_ATTR_MAP,omitempty"`

	// Alternative to user search, if user DNs are all of the same format. This approach is more efficient for user lookups than searching if it is usable in your organizational environment. If this setting has a value it will be used instead of AUTH_LDAP_USER_SEARCH.
	AUTHLDAPUSERDNTEMPLATE string `json:"AUTH_LDAP_USER_DN_TEMPLATE,omitempty"`

	// Retrieve users from a given group. At this time, superuser and system auditors are the only groups supported. Refer to the Ansible Tower documentation for more detail.
	AUTHLDAPUSERFLAGSBYGROUP interface{} `json:"AUTH_LDAP_USER_FLAGS_BY_GROUP,omitempty"`

	// LDAP search query to find users.  Any user that matches the given pattern will be able to login to Tower.  The user should also be mapped into a Tower organization (as defined in the AUTH_LDAP_ORGANIZATION_MAP setting).  If multiple search queries need to be supported use of "LDAPUnion" is possible. See Tower documentation for details.
	AUTHLDAPUSERSEARCH []string `json:"AUTH_LDAP_USER_SEARCH"`

	// Interval (in seconds) between data gathering.
	AUTOMATIONANALYTICSGATHERINTERVAL int64 `json:"AUTOMATION_ANALYTICS_GATHER_INTERVAL,omitempty"`

	// a u t o m a t i o n a n a l y t i c s l a s t g a t h e r
	// Required: true
	AUTOMATIONANALYTICSLASTGATHER *string `json:"AUTOMATION_ANALYTICS_LAST_GATHER"`

	// This setting is used to to configure data collection for the Automation Analytics dashboard
	AUTOMATIONANALYTICSURL string `json:"AUTOMATION_ANALYTICS_URL,omitempty"`

	// List of paths to search for extra callback plugins to be used when running jobs. Enter one path per line.
	AWXANSIBLECALLBACKPLUGINS []string `json:"AWX_ANSIBLE_CALLBACK_PLUGINS"`

	// Allows collections to be dynamically downloaded from a requirements.yml file for SCM projects.
	AWXCOLLECTIONSENABLED bool `json:"AWX_COLLECTIONS_ENABLED,omitempty"`

	// The number of seconds to sleep between status checks for jobs running on isolated instances.
	// Required: true
	AWXISOLATEDCHECKINTERVAL *int64 `json:"AWX_ISOLATED_CHECK_INTERVAL"`

	// Ansible SSH connection timeout (in seconds) to use when communicating with isolated instances. Value should be substantially greater than expected network latency.
	AWXISOLATEDCONNECTIONTIMEOUT int64 `json:"AWX_ISOLATED_CONNECTION_TIMEOUT,omitempty"`

	// When set to True, AWX will enforce strict host key checking for communication with isolated nodes.
	AWXISOLATEDHOSTKEYCHECKING bool `json:"AWX_ISOLATED_HOST_KEY_CHECKING,omitempty"`

	// The timeout (in seconds) for launching jobs on isolated instances.  This includes the time needed to copy source control files (playbooks) to the isolated instance.
	// Required: true
	AWXISOLATEDLAUNCHTIMEOUT *int64 `json:"AWX_ISOLATED_LAUNCH_TIMEOUT"`

	// This can be raised to aid in debugging connection issues for isolated task execution
	AWXISOLATEDVERBOSITY int64 `json:"AWX_ISOLATED_VERBOSITY,omitempty"`

	// The directory in which Tower will create new temporary directories for job execution and isolation (such as credential files and custom inventory scripts).
	// Required: true
	AWXPROOTBASEPATH *string `json:"AWX_PROOT_BASE_PATH"`

	// Isolates an Ansible job from protected parts of the system to prevent exposing sensitive information.
	// Required: true
	AWXPROOTENABLED *bool `json:"AWX_PROOT_ENABLED"`

	// Additional paths to hide from isolated processes. Enter one path per line.
	AWXPROOTHIDEPATHS []string `json:"AWX_PROOT_HIDE_PATHS"`

	// Whitelist of paths that would otherwise be hidden to expose to isolated jobs. Enter one path per line.
	AWXPROOTSHOWPATHS []string `json:"AWX_PROOT_SHOW_PATHS"`

	// Interval (in seconds) between polls for cpu usage. Setting this lower than the default will affect playbook performance.
	AWXRESOURCEPROFILINGCPUPOLLINTERVAL float64 `json:"AWX_RESOURCE_PROFILING_CPU_POLL_INTERVAL,omitempty"`

	// If set, detailed resource profiling data will be collected on all jobs. This data can be gathered with `sosreport`.
	AWXRESOURCEPROFILINGENABLED bool `json:"AWX_RESOURCE_PROFILING_ENABLED,omitempty"`

	// Interval (in seconds) between polls for memory usage. Setting this lower than the default will affect playbook performance.
	AWXRESOURCEPROFILINGMEMORYPOLLINTERVAL float64 `json:"AWX_RESOURCE_PROFILING_MEMORY_POLL_INTERVAL,omitempty"`

	// Interval (in seconds) between polls for PID count. Setting this lower than the default will affect playbook performance.
	AWXRESOURCEPROFILINGPIDPOLLINTERVAL float64 `json:"AWX_RESOURCE_PROFILING_PID_POLL_INTERVAL,omitempty"`

	// Allows roles to be dynamically downloaded from a requirements.yml file for SCM projects.
	AWXROLESENABLED bool `json:"AWX_ROLES_ENABLED,omitempty"`

	// Additional environment variables set for playbook runs, inventory updates, project updates, and notification sending.
	AWXTASKENV interface{} `json:"AWX_TASK_ENV,omitempty"`

	// When set (the default), underlying queues will be persisted to disk.  Disable this to enable higher message bus throughput.
	// Required: true
	BROKERDURABILITY *bool `json:"BROKER_DURABILITY"`

	// If needed, you can add specific information (such as a legal notice or a disclaimer) to a text box in the login modal using this setting. Any content added must be in plain text, as custom HTML or other markup languages are not supported.
	CUSTOMLOGININFO string `json:"CUSTOM_LOGIN_INFO,omitempty"`

	// To set up a custom logo, provide a file that you create. For the custom logo to look its best, use a .png file with a transparent background. GIF, PNG and JPEG formats are supported.
	CUSTOMLOGO string `json:"CUSTOM_LOGO,omitempty"`

	// Paths where Tower will look for custom virtual environments (in addition to /var/lib/awx/venv/). Enter one path per line.
	CUSTOMVENVPATHS []string `json:"CUSTOM_VENV_PATHS"`

	// Maximum time in seconds to allow inventory updates to run. Use value of 0 to indicate that no timeout should be imposed. A timeout set on an individual inventory source will override this.
	DEFAULTINVENTORYUPDATETIMEOUT int64 `json:"DEFAULT_INVENTORY_UPDATE_TIMEOUT,omitempty"`

	// Maximum time in seconds to allow jobs to run. Use value of 0 to indicate that no timeout should be imposed. A timeout set on an individual job template will override this.
	DEFAULTJOBTIMEOUT int64 `json:"DEFAULT_JOB_TIMEOUT,omitempty"`

	// Maximum time in seconds to allow project updates to run. Use value of 0 to indicate that no timeout should be imposed. A timeout set on an individual project will override this.
	DEFAULTPROJECTUPDATETIMEOUT int64 `json:"DEFAULT_PROJECT_UPDATE_TIMEOUT,omitempty"`

	// Maximum Size of Standard Output in bytes to display for a single job or ad hoc command event. `stdout` will end with `…` when truncated.
	// Required: true
	EVENTSTDOUTMAXBYTESDISPLAY *int64 `json:"EVENT_STDOUT_MAX_BYTES_DISPLAY"`

	// If set to true, certificate validation will not be done wheninstalling content from any Galaxy server.
	GALAXYIGNORECERTS bool `json:"GALAXY_IGNORE_CERTS,omitempty"`

	// Enables Tower to gather data on automation and send it to Red Hat.
	INSIGHTSTRACKINGSTATE bool `json:"INSIGHTS_TRACKING_STATE,omitempty"`

	// URL to which unauthorized users will be redirected to log in. If blank, users will be sent to the Tower login page.
	LOGINREDIRECTOVERRIDE string `json:"LOGIN_REDIRECT_OVERRIDE,omitempty"`

	// When enabled, all external logs emitted by Tower will also be written to /var/log/tower/external.log.  This is an experimental setting intended to be used for debugging external log aggregation issues (and may be subject to change in the future).
	LOGAGGREGATORAUDIT bool `json:"LOG_AGGREGATOR_AUDIT,omitempty"`

	// Enable sending logs to external log aggregator.
	LOGAGGREGATORENABLED bool `json:"LOG_AGGREGATOR_ENABLED,omitempty"`

	// Hostname/IP where external logs will be sent to.
	LOGAGGREGATORHOST string `json:"LOG_AGGREGATOR_HOST,omitempty"`

	// If set, system tracking facts will be sent for each package, service, or other item found in a scan, allowing for greater search query granularity. If unset, facts will be sent as a single dictionary, allowing for greater efficiency in fact processing.
	LOGAGGREGATORINDIVIDUALFACTS bool `json:"LOG_AGGREGATOR_INDIVIDUAL_FACTS,omitempty"`

	// Level threshold used by log handler. Severities from lowest to highest are DEBUG, INFO, WARNING, ERROR, CRITICAL. Messages less severe than the threshold will be ignored by log handler. (messages under category awx.anlytics ignore this setting)
	LOGAGGREGATORLEVEL string `json:"LOG_AGGREGATOR_LEVEL,omitempty"`

	// List of loggers that will send HTTP logs to the collector, these can include any or all of:
	// awx - service logs
	// activity_stream - activity stream records
	// job_events - callback data from Ansible job events
	// system_tracking - facts gathered from scan jobs.
	LOGAGGREGATORLOGGERS []string `json:"LOG_AGGREGATOR_LOGGERS"`

	// Amount of data to store (in gigabytes) during an outage of the external log aggregator (defaults to 1). Equivalent to the rsyslogd queue.maxdiskspace setting.
	LOGAGGREGATORMAXDISKUSAGEGB int64 `json:"LOG_AGGREGATOR_MAX_DISK_USAGE_GB,omitempty"`

	// Location to persist logs that should be retried after an outage of the external log aggregator (defaults to /var/lib/awx). Equivalent to the rsyslogd queue.spoolDirectory setting.
	LOGAGGREGATORMAXDISKUSAGEPATH string `json:"LOG_AGGREGATOR_MAX_DISK_USAGE_PATH,omitempty"`

	// Password or authentication token for external log aggregator (if required; HTTP/s only).
	LOGAGGREGATORPASSWORD string `json:"LOG_AGGREGATOR_PASSWORD,omitempty"`

	// Port on Logging Aggregator to send logs to (if required and not provided in Logging Aggregator).
	LOGAGGREGATORPORT int64 `json:"LOG_AGGREGATOR_PORT,omitempty"`

	// Protocol used to communicate with log aggregator.  HTTPS/HTTP assumes HTTPS unless http:// is explicitly used in the Logging Aggregator hostname.
	LOGAGGREGATORPROTOCOL string `json:"LOG_AGGREGATOR_PROTOCOL,omitempty"`

	// Enabled high verbosity debugging for rsyslogd.  Useful for debugging connection issues for external log aggregation.
	LOGAGGREGATORRSYSLOGDDEBUG bool `json:"LOG_AGGREGATOR_RSYSLOGD_DEBUG,omitempty"`

	// Number of seconds for a TCP connection to external log aggregator to timeout. Applies to HTTPS and TCP log aggregator protocols.
	LOGAGGREGATORTCPTIMEOUT int64 `json:"LOG_AGGREGATOR_TCP_TIMEOUT,omitempty"`

	// Useful to uniquely identify Tower instances.
	LOGAGGREGATORTOWERUUID string `json:"LOG_AGGREGATOR_TOWER_UUID,omitempty"`

	// Format messages for the chosen log aggregator.
	LOGAGGREGATORTYPE string `json:"LOG_AGGREGATOR_TYPE,omitempty"`

	// Username for external log aggregator (if required; HTTP/s only).
	LOGAGGREGATORUSERNAME string `json:"LOG_AGGREGATOR_USERNAME,omitempty"`

	// Flag to control enable/disable of certificate verification when LOG_AGGREGATOR_PROTOCOL is "https". If enabled, Tower's log handler will verify certificate sent by external log aggregator before establishing connection.
	LOGAGGREGATORVERIFYCERT bool `json:"LOG_AGGREGATOR_VERIFY_CERT,omitempty"`

	// Controls whether any Organization Admin has the privileges to create and manage users and teams. You may want to disable this ability if you are using an LDAP or SAML integration.
	// Required: true
	MANAGEORGANIZATIONAUTH *bool `json:"MANAGE_ORGANIZATION_AUTH"`

	// Saving a Job Template with more than this number of forks will result in an error. When set to 0, no limit is applied.
	MAXFORKS int64 `json:"MAX_FORKS,omitempty"`

	// Maximum number of job events for the UI to retrieve within a single request.
	// Required: true
	MAXUIJOBEVENTS *int64 `json:"MAX_UI_JOB_EVENTS"`

	// Dictionary for customizing OAuth 2 timeouts, available items are `ACCESS_TOKEN_EXPIRE_SECONDS`, the duration of access tokens in the number of seconds, `AUTHORIZATION_CODE_EXPIRE_SECONDS`, the duration of authorization codes in the number of seconds, and `REFRESH_TOKEN_EXPIRE_SECONDS`, the duration of refresh tokens, after expired access tokens, in the number of seconds.
	OAUTH2PROVIDER interface{} `json:"OAUTH2_PROVIDER,omitempty"`

	// Controls whether any Organization Admin can view all users and teams, even those not associated with their Organization.
	// Required: true
	ORGADMINSCANSEEALLUSERS *bool `json:"ORG_ADMINS_CAN_SEE_ALL_USERS"`

	// For using a galaxy server at higher precedence than the public Ansible Galaxy. The token_endpoint of a Keycloak server.
	PRIMARYGALAXYAUTHURL string `json:"PRIMARY_GALAXY_AUTH_URL,omitempty"`

	// For using a galaxy server at higher precedence than the public Ansible Galaxy. The password to use for basic authentication against the Galaxy instance, this is mutually exclusive with PRIMARY_GALAXY_TOKEN.
	PRIMARYGALAXYPASSWORD string `json:"PRIMARY_GALAXY_PASSWORD,omitempty"`

	// For using a galaxy server at higher precedence than the public Ansible Galaxy. The token to use for connecting with the Galaxy instance, this is mutually exclusive with corresponding username and password settings.
	PRIMARYGALAXYTOKEN string `json:"PRIMARY_GALAXY_TOKEN,omitempty"`

	// For organizations that run their own Galaxy service, this gives the option to specify a host as the primary galaxy server. Requirements will be downloaded from the primary if the specific role or collection is available there. If the content is not avilable in the primary, or if this field is left blank, it will default to galaxy.ansible.com.
	PRIMARYGALAXYURL string `json:"PRIMARY_GALAXY_URL,omitempty"`

	// For using a galaxy server at higher precedence than the public Ansible Galaxy. The username to use for basic authentication against the Galaxy instance, this is mutually exclusive with PRIMARY_GALAXY_TOKEN.
	PRIMARYGALAXYUSERNAME string `json:"PRIMARY_GALAXY_USERNAME,omitempty"`

	// Adds the CLI -vvv flag to ansible-playbook runs of project_update.yml used for project updates.
	// Required: true
	PROJECTUPDATEVVV *bool `json:"PROJECT_UPDATE_VVV"`

	// If Tower is behind a reverse proxy/load balancer, use this setting to whitelist the proxy IP addresses from which Tower should trust custom REMOTE_HOST_HEADERS header values. If this setting is an empty list (the default), the headers specified by REMOTE_HOST_HEADERS will be trusted unconditionally')
	// Required: true
	PROXYIPWHITELIST []string `json:"PROXY_IP_WHITELIST"`

	// Allow or deny access to the public Ansible Galaxy during project updates.
	PUBLICGALAXYENABLED bool `json:"PUBLIC_GALAXY_ENABLED,omitempty"`

	// Port of RADIUS server.
	RADIUSPORT int64 `json:"RADIUS_PORT,omitempty"`

	// Shared secret for authenticating to RADIUS server.
	RADIUSSECRET string `json:"RADIUS_SECRET,omitempty"`

	// Hostname/IP of RADIUS server. RADIUS authentication is disabled if this setting is empty.
	RADIUSSERVER string `json:"RADIUS_SERVER,omitempty"`

	// This password is used to retrieve license information and to send Automation Analytics
	REDHATPASSWORD string `json:"REDHAT_PASSWORD,omitempty"`

	// This username is used to retrieve license information and to send Automation Analytics
	REDHATUSERNAME string `json:"REDHAT_USERNAME,omitempty"`

	// HTTP headers and meta keys to search to determine remote host name or IP. Add additional items to this list, such as "HTTP_X_FORWARDED_FOR", if behind a reverse proxy. See the "Proxy Support" section of the Adminstrator guide for more details.
	// Required: true
	REMOTEHOSTHEADERS []string `json:"REMOTE_HOST_HEADERS"`

	// Maximum number of the same job template that can be waiting to run when launching from a schedule before no more are created.
	// Required: true
	SCHEDULEMAXJOBS *int64 `json:"SCHEDULE_MAX_JOBS"`

	// Maximum number of simultaneous logged in sessions a user may have. To disable enter -1.
	// Required: true
	SESSIONSPERUSER *int64 `json:"SESSIONS_PER_USER"`

	// Number of seconds that a user is inactive before they will need to login again.
	// Required: true
	SESSIONCOOKIEAGE *int64 `json:"SESSION_COOKIE_AGE"`

	// The OAuth2 key (Client ID) from your Azure AD application.
	SOCIALAUTHAZUREADOAUTH2KEY string `json:"SOCIAL_AUTH_AZUREAD_OAUTH2_KEY,omitempty"`

	// Mapping to organization admins/users from social auth accounts. This setting
	// controls which users are placed into which Tower organizations based on their
	// username and email address. Configuration details are available in the Ansible
	// Tower documentation.
	SOCIALAUTHAZUREADOAUTH2ORGANIZATIONMAP interface{} `json:"SOCIAL_AUTH_AZUREAD_OAUTH2_ORGANIZATION_MAP,omitempty"`

	// The OAuth2 secret (Client Secret) from your Azure AD application.
	SOCIALAUTHAZUREADOAUTH2SECRET string `json:"SOCIAL_AUTH_AZUREAD_OAUTH2_SECRET,omitempty"`

	// Mapping of team members (users) from social auth accounts. Configuration
	// details are available in Tower documentation.
	SOCIALAUTHAZUREADOAUTH2TEAMMAP interface{} `json:"SOCIAL_AUTH_AZUREAD_OAUTH2_TEAM_MAP,omitempty"`

	// The OAuth2 key (Client ID) from your GitHub developer application.
	SOCIALAUTHGITHUBKEY string `json:"SOCIAL_AUTH_GITHUB_KEY,omitempty"`

	// Mapping to organization admins/users from social auth accounts. This setting
	// controls which users are placed into which Tower organizations based on their
	// username and email address. Configuration details are available in the Ansible
	// Tower documentation.
	SOCIALAUTHGITHUBORGANIZATIONMAP interface{} `json:"SOCIAL_AUTH_GITHUB_ORGANIZATION_MAP,omitempty"`

	// The OAuth2 key (Client ID) from your GitHub organization application.
	SOCIALAUTHGITHUBORGKEY string `json:"SOCIAL_AUTH_GITHUB_ORG_KEY,omitempty"`

	// The name of your GitHub organization, as used in your organization's URL: https://github.com/<yourorg>/.
	SOCIALAUTHGITHUBORGNAME string `json:"SOCIAL_AUTH_GITHUB_ORG_NAME,omitempty"`

	// Mapping to organization admins/users from social auth accounts. This setting
	// controls which users are placed into which Tower organizations based on their
	// username and email address. Configuration details are available in the Ansible
	// Tower documentation.
	SOCIALAUTHGITHUBORGORGANIZATIONMAP interface{} `json:"SOCIAL_AUTH_GITHUB_ORG_ORGANIZATION_MAP,omitempty"`

	// The OAuth2 secret (Client Secret) from your GitHub organization application.
	SOCIALAUTHGITHUBORGSECRET string `json:"SOCIAL_AUTH_GITHUB_ORG_SECRET,omitempty"`

	// Mapping of team members (users) from social auth accounts. Configuration
	// details are available in Tower documentation.
	SOCIALAUTHGITHUBORGTEAMMAP interface{} `json:"SOCIAL_AUTH_GITHUB_ORG_TEAM_MAP,omitempty"`

	// The OAuth2 secret (Client Secret) from your GitHub developer application.
	SOCIALAUTHGITHUBSECRET string `json:"SOCIAL_AUTH_GITHUB_SECRET,omitempty"`

	// Find the numeric team ID using the Github API: http://fabian-kostadinov.github.io/2015/01/16/how-to-find-a-github-team-id/.
	SOCIALAUTHGITHUBTEAMID string `json:"SOCIAL_AUTH_GITHUB_TEAM_ID,omitempty"`

	// The OAuth2 key (Client ID) from your GitHub organization application.
	SOCIALAUTHGITHUBTEAMKEY string `json:"SOCIAL_AUTH_GITHUB_TEAM_KEY,omitempty"`

	// Mapping of team members (users) from social auth accounts. Configuration
	// details are available in Tower documentation.
	SOCIALAUTHGITHUBTEAMMAP interface{} `json:"SOCIAL_AUTH_GITHUB_TEAM_MAP,omitempty"`

	// Mapping to organization admins/users from social auth accounts. This setting
	// controls which users are placed into which Tower organizations based on their
	// username and email address. Configuration details are available in the Ansible
	// Tower documentation.
	SOCIALAUTHGITHUBTEAMORGANIZATIONMAP interface{} `json:"SOCIAL_AUTH_GITHUB_TEAM_ORGANIZATION_MAP,omitempty"`

	// The OAuth2 secret (Client Secret) from your GitHub organization application.
	SOCIALAUTHGITHUBTEAMSECRET string `json:"SOCIAL_AUTH_GITHUB_TEAM_SECRET,omitempty"`

	// Mapping of team members (users) from social auth accounts. Configuration
	// details are available in Tower documentation.
	SOCIALAUTHGITHUBTEAMTEAMMAP interface{} `json:"SOCIAL_AUTH_GITHUB_TEAM_TEAM_MAP,omitempty"`

	// Extra arguments for Google OAuth2 login. You can restrict it to only allow a single domain to authenticate, even if the user is logged in with multple Google accounts. Refer to the Ansible Tower documentation for more detail.
	SOCIALAUTHGOOGLEOAUTH2AUTHEXTRAARGUMENTS interface{} `json:"SOCIAL_AUTH_GOOGLE_OAUTH2_AUTH_EXTRA_ARGUMENTS,omitempty"`

	// The OAuth2 key from your web application.
	SOCIALAUTHGOOGLEOAUTH2KEY string `json:"SOCIAL_AUTH_GOOGLE_OAUTH2_KEY,omitempty"`

	// Mapping to organization admins/users from social auth accounts. This setting
	// controls which users are placed into which Tower organizations based on their
	// username and email address. Configuration details are available in the Ansible
	// Tower documentation.
	SOCIALAUTHGOOGLEOAUTH2ORGANIZATIONMAP interface{} `json:"SOCIAL_AUTH_GOOGLE_OAUTH2_ORGANIZATION_MAP,omitempty"`

	// The OAuth2 secret from your web application.
	SOCIALAUTHGOOGLEOAUTH2SECRET string `json:"SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET,omitempty"`

	// Mapping of team members (users) from social auth accounts. Configuration
	// details are available in Tower documentation.
	SOCIALAUTHGOOGLEOAUTH2TEAMMAP interface{} `json:"SOCIAL_AUTH_GOOGLE_OAUTH2_TEAM_MAP,omitempty"`

	// Update this setting to restrict the domains who are allowed to login using Google OAuth2.
	SOCIALAUTHGOOGLEOAUTH2WHITELISTEDDOMAINS []string `json:"SOCIAL_AUTH_GOOGLE_OAUTH2_WHITELISTED_DOMAINS"`

	// Mapping to organization admins/users from social auth accounts. This setting
	// controls which users are placed into which Tower organizations based on their
	// username and email address. Configuration details are available in the Ansible
	// Tower documentation.
	SOCIALAUTHORGANIZATIONMAP interface{} `json:"SOCIAL_AUTH_ORGANIZATION_MAP,omitempty"`

	// Configure the Entity ID, SSO URL and certificate for each identity provider (IdP) in use. Multiple SAML IdPs are supported. Some IdPs may provide user data using attribute names that differ from the default OIDs. Attribute names may be overridden for each IdP. Refer to the Ansible documentation for additional details and syntax.
	SOCIALAUTHSAMLENABLEDIDPS interface{} `json:"SOCIAL_AUTH_SAML_ENABLED_IDPS,omitempty"`

	// A list of tuples that maps IDP attributes to extra_attributes. Each attribute will be a list of values, even if only 1 value.
	SOCIALAUTHSAMLEXTRADATA []string `json:"SOCIAL_AUTH_SAML_EXTRA_DATA"`

	// Used to translate user organization membership into Tower.
	SOCIALAUTHSAMLORGANIZATIONATTR interface{} `json:"SOCIAL_AUTH_SAML_ORGANIZATION_ATTR,omitempty"`

	// Mapping to organization admins/users from social auth accounts. This setting
	// controls which users are placed into which Tower organizations based on their
	// username and email address. Configuration details are available in the Ansible
	// Tower documentation.
	SOCIALAUTHSAMLORGANIZATIONMAP interface{} `json:"SOCIAL_AUTH_SAML_ORGANIZATION_MAP,omitempty"`

	// Provide the URL, display name, and the name of your app. Refer to the Ansible Tower documentation for example syntax.
	// Required: true
	SOCIALAUTHSAMLORGINFO interface{} `json:"SOCIAL_AUTH_SAML_ORG_INFO"`

	// A dict of key value pairs that are passed to the underlying python-saml security setting https://github.com/onelogin/python-saml#settings
	SOCIALAUTHSAMLSECURITYCONFIG interface{} `json:"SOCIAL_AUTH_SAML_SECURITY_CONFIG,omitempty"`

	// The application-defined unique identifier used as the audience of the SAML service provider (SP) configuration. This is usually the URL for Tower.
	SOCIALAUTHSAMLSPENTITYID string `json:"SOCIAL_AUTH_SAML_SP_ENTITY_ID,omitempty"`

	// A dict of key value pairs to be passed to the underlying python-saml Service Provider configuration setting.
	SOCIALAUTHSAMLSPEXTRA interface{} `json:"SOCIAL_AUTH_SAML_SP_EXTRA,omitempty"`

	// Create a keypair for Tower to use as a service provider (SP) and include the private key content here.
	// Required: true
	SOCIALAUTHSAMLSPPRIVATEKEY *string `json:"SOCIAL_AUTH_SAML_SP_PRIVATE_KEY"`

	// Create a keypair for Tower to use as a service provider (SP) and include the certificate content here.
	// Required: true
	SOCIALAUTHSAMLSPPUBLICCERT *string `json:"SOCIAL_AUTH_SAML_SP_PUBLIC_CERT"`

	// Provide the name and email address of the support contact for your service provider. Refer to the Ansible Tower documentation for example syntax.
	// Required: true
	SOCIALAUTHSAMLSUPPORTCONTACT interface{} `json:"SOCIAL_AUTH_SAML_SUPPORT_CONTACT"`

	// Used to translate user team membership into Tower.
	SOCIALAUTHSAMLTEAMATTR interface{} `json:"SOCIAL_AUTH_SAML_TEAM_ATTR,omitempty"`

	// Mapping of team members (users) from social auth accounts. Configuration
	// details are available in Tower documentation.
	SOCIALAUTHSAMLTEAMMAP interface{} `json:"SOCIAL_AUTH_SAML_TEAM_MAP,omitempty"`

	// Provide the name and email address of the technical contact for your service provider. Refer to the Ansible Tower documentation for example syntax.
	// Required: true
	SOCIALAUTHSAMLTECHNICALCONTACT interface{} `json:"SOCIAL_AUTH_SAML_TECHNICAL_CONTACT"`

	// Mapping of team members (users) from social auth accounts. Configuration
	// details are available in Tower documentation.
	SOCIALAUTHTEAMMAP interface{} `json:"SOCIAL_AUTH_TEAM_MAP,omitempty"`

	// When set to an empty list `[]`, this setting prevents new user accounts from being created. Only users who have previously logged in using social auth or have a user account with a matching email address will be able to login.
	SOCIALAUTHUSERFIELDS []string `json:"SOCIAL_AUTH_USER_FIELDS"`

	// Maximum Size of Standard Output in bytes to display before requiring the output be downloaded.
	// Required: true
	STDOUTMAXBYTESDISPLAY *int64 `json:"STDOUT_MAX_BYTES_DISPLAY"`

	// Choose the authentication protocol used by TACACS+ client.
	TACACSPLUSAUTHPROTOCOL string `json:"TACACSPLUS_AUTH_PROTOCOL,omitempty"`

	// Hostname of TACACS+ server.
	TACACSPLUSHOST string `json:"TACACSPLUS_HOST,omitempty"`

	// Port number of TACACS+ server.
	TACACSPLUSPORT int64 `json:"TACACSPLUS_PORT,omitempty"`

	// Shared secret for authenticating to TACACS+ server.
	TACACSPLUSSECRET string `json:"TACACSPLUS_SECRET,omitempty"`

	// TACACS+ session timeout value in seconds, 0 disables timeout.
	TACACSPLUSSESSIONTIMEOUT int64 `json:"TACACSPLUS_SESSION_TIMEOUT,omitempty"`

	// This setting is used by services like notifications to render a valid url to the Tower host.
	// Required: true
	TOWERURLBASE *string `json:"TOWER_URL_BASE"`

	// If disabled, the page will not refresh when events are received. Reloading the page will be required to get the latest details.
	// Required: true
	UILIVEUPDATESENABLED *bool `json:"UI_LIVE_UPDATES_ENABLED"`
}

// Validate validates this settings settings logging test create body
func (o *SettingsSettingsLoggingTestCreateBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateACTIVITYSTREAMENABLED(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateACTIVITYSTREAMENABLEDFORINVENTORYSYNC(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateALLOWJINJAINEXTRAVARS(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAUTHBASICENABLED(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAUTOMATIONANALYTICSLASTGATHER(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAWXISOLATEDCHECKINTERVAL(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAWXISOLATEDLAUNCHTIMEOUT(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAWXPROOTBASEPATH(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAWXPROOTENABLED(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBROKERDURABILITY(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEVENTSTDOUTMAXBYTESDISPLAY(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMANAGEORGANIZATIONAUTH(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMAXUIJOBEVENTS(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateORGADMINSCANSEEALLUSERS(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePROJECTUPDATEVVV(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePROXYIPWHITELIST(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateREMOTEHOSTHEADERS(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSCHEDULEMAXJOBS(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSESSIONSPERUSER(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSESSIONCOOKIEAGE(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSOCIALAUTHSAMLORGINFO(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSOCIALAUTHSAMLSPPRIVATEKEY(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSOCIALAUTHSAMLSPPUBLICCERT(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSOCIALAUTHSAMLSUPPORTCONTACT(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSOCIALAUTHSAMLTECHNICALCONTACT(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSTDOUTMAXBYTESDISPLAY(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTOWERURLBASE(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUILIVEUPDATESENABLED(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateACTIVITYSTREAMENABLED(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"ACTIVITY_STREAM_ENABLED", "body", o.ACTIVITYSTREAMENABLED); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateACTIVITYSTREAMENABLEDFORINVENTORYSYNC(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"ACTIVITY_STREAM_ENABLED_FOR_INVENTORY_SYNC", "body", o.ACTIVITYSTREAMENABLEDFORINVENTORYSYNC); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateALLOWJINJAINEXTRAVARS(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"ALLOW_JINJA_IN_EXTRA_VARS", "body", o.ALLOWJINJAINEXTRAVARS); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateAUTHBASICENABLED(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"AUTH_BASIC_ENABLED", "body", o.AUTHBASICENABLED); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateAUTOMATIONANALYTICSLASTGATHER(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"AUTOMATION_ANALYTICS_LAST_GATHER", "body", o.AUTOMATIONANALYTICSLASTGATHER); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateAWXISOLATEDCHECKINTERVAL(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"AWX_ISOLATED_CHECK_INTERVAL", "body", o.AWXISOLATEDCHECKINTERVAL); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateAWXISOLATEDLAUNCHTIMEOUT(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"AWX_ISOLATED_LAUNCH_TIMEOUT", "body", o.AWXISOLATEDLAUNCHTIMEOUT); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateAWXPROOTBASEPATH(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"AWX_PROOT_BASE_PATH", "body", o.AWXPROOTBASEPATH); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateAWXPROOTENABLED(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"AWX_PROOT_ENABLED", "body", o.AWXPROOTENABLED); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateBROKERDURABILITY(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"BROKER_DURABILITY", "body", o.BROKERDURABILITY); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateEVENTSTDOUTMAXBYTESDISPLAY(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"EVENT_STDOUT_MAX_BYTES_DISPLAY", "body", o.EVENTSTDOUTMAXBYTESDISPLAY); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateMANAGEORGANIZATIONAUTH(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"MANAGE_ORGANIZATION_AUTH", "body", o.MANAGEORGANIZATIONAUTH); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateMAXUIJOBEVENTS(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"MAX_UI_JOB_EVENTS", "body", o.MAXUIJOBEVENTS); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateORGADMINSCANSEEALLUSERS(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"ORG_ADMINS_CAN_SEE_ALL_USERS", "body", o.ORGADMINSCANSEEALLUSERS); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validatePROJECTUPDATEVVV(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"PROJECT_UPDATE_VVV", "body", o.PROJECTUPDATEVVV); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validatePROXYIPWHITELIST(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"PROXY_IP_WHITELIST", "body", o.PROXYIPWHITELIST); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateREMOTEHOSTHEADERS(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"REMOTE_HOST_HEADERS", "body", o.REMOTEHOSTHEADERS); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateSCHEDULEMAXJOBS(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"SCHEDULE_MAX_JOBS", "body", o.SCHEDULEMAXJOBS); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateSESSIONSPERUSER(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"SESSIONS_PER_USER", "body", o.SESSIONSPERUSER); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateSESSIONCOOKIEAGE(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"SESSION_COOKIE_AGE", "body", o.SESSIONCOOKIEAGE); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateSOCIALAUTHSAMLORGINFO(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"SOCIAL_AUTH_SAML_ORG_INFO", "body", o.SOCIALAUTHSAMLORGINFO); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateSOCIALAUTHSAMLSPPRIVATEKEY(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"SOCIAL_AUTH_SAML_SP_PRIVATE_KEY", "body", o.SOCIALAUTHSAMLSPPRIVATEKEY); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateSOCIALAUTHSAMLSPPUBLICCERT(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"SOCIAL_AUTH_SAML_SP_PUBLIC_CERT", "body", o.SOCIALAUTHSAMLSPPUBLICCERT); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateSOCIALAUTHSAMLSUPPORTCONTACT(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"SOCIAL_AUTH_SAML_SUPPORT_CONTACT", "body", o.SOCIALAUTHSAMLSUPPORTCONTACT); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateSOCIALAUTHSAMLTECHNICALCONTACT(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"SOCIAL_AUTH_SAML_TECHNICAL_CONTACT", "body", o.SOCIALAUTHSAMLTECHNICALCONTACT); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateSTDOUTMAXBYTESDISPLAY(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"STDOUT_MAX_BYTES_DISPLAY", "body", o.STDOUTMAXBYTESDISPLAY); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateTOWERURLBASE(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"TOWER_URL_BASE", "body", o.TOWERURLBASE); err != nil {
		return err
	}

	return nil
}

func (o *SettingsSettingsLoggingTestCreateBody) validateUILIVEUPDATESENABLED(formats strfmt.Registry) error {

	if err := validate.Required("data"+"."+"UI_LIVE_UPDATES_ENABLED", "body", o.UILIVEUPDATESENABLED); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SettingsSettingsLoggingTestCreateBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SettingsSettingsLoggingTestCreateBody) UnmarshalBinary(b []byte) error {
	var res SettingsSettingsLoggingTestCreateBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
